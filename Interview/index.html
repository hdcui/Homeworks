<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>前端面试题(HTML+CSS)</title>
    <link href="./css/bootstrap.min.css" rel="stylesheet">
    <style type="text/css">
    body {
        font-family: Microsoft JhengHei;
        font-size: 16px;
        min-width: 400px;
    }
    
    h4,
    p,
    section {
        padding: 10px;
        border-radius: 3px;
        box-shadow: -2px -2px 3px rgb(66, 66, 66);
    }
    
    section {
        padding: 15px 0;
    }
    
    p {
        text-indent: 30px;
    }
    
    .p-same {
        padding: 0 10px;
        margin-bottom: 0;
        border-radius: 0;
        box-shadow: none;
    }
    
    footer {
        clear: both;
        padding: 15px;
    }
    </style>
</head>

<body class="bg-success">
    <!-- page body -->
    <div class="container">
        <div class="row">
            <div class="col-lg-12 bg-success">
                <!-- page head -->
                <header class="text-center">
                    <h1>高级前端面试题</h1>
                </header>
                <!-- page content -->
                <article class="col-md-10 col-md-offset-1 text-left">
                    <!-- Question 1 -->
                    <h4 class="bg-primary">Q1:对WEB标准以及W3C的理解与认识。</h4>
                    <p class="bg-danger">标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性</p>
                    <!-- Question 2 -->
                    <h4 class="bg-primary">Q2:每个HTML文件里开头都有个很重要的东西，<code>&lt;!DOCTYPE&gt;</code>，知道这是干什么的吗？</h4>
                    <p class="bg-danger"><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面的位置，处于 <code>&lt;html&gt;</code>标签之前。一个将提醒用户代理和验证程序该文档使用什么DTD；另一个是提醒浏览器按照标准模式而不是怪异模式来解释文档。如果包含了doctype ，那么浏览器会试图按照严格方式来解释标记，如果没有doctype，就会触发怪异模式，按照旧的不正确的方式来解释标记。</p>
                    <!-- Question 3 -->
                    <h4 class="bg-primary">Q3:XHTML和HTML有什么区别？</h4>
                    <section class="bg-danger">
                        <p class="p-same">HTML是一种基于标准通用标记语言(SGML)的应用，而XHTML则基于可扩展标记语言(XML)，HTML和XHTML其实是平行发展的两个标准。最主要的不同在于，XHTML的语法更为严谨：</p>
                        <p class="p-same">1.所有标签都必须小写；</p>
                        <p class="p-same">2.标签必须成双成对；</p>
                        <p class="p-same">3.标签顺序必须正确；</p>
                        <p class="p-same">4.所有属性都必须使用双引号。</p>
                    </section>
                    <!-- Question 4 -->
                    <h4 class="bg-primary">Q4:行内元素有哪些？块级元素有哪些？CSS的盒模型？</h4>
                    <section class="bg-danger">
                        <p class="p-same">行内元素：a，img，span，b，em，font，input，label，select，strike，strong，sub，sup，u</p>
                        <p class="p-same">块级元素：div，table，form，ul，ol，p，h1~h6，hr</p>
                        <p class="p-same">CSS盒模型：content-box，padding-box，border-box，margin-box</p>
                    </section>
                    <!-- Question 5 -->
                    <h4 class="bg-primary">Q5:CSS引入的方式有哪些? link和@import的区别是?</h4>
                    <section class="bg-danger">
                        <p class="p-same">CSS引入的方式有：内联(标签内书写)，内嵌(页面头部书写)，外链(外链CSS样式表)</p>
                        <p class="p-same">link和@import都是外部引入CSS的方式，区别在于：</p>
                        <p class="p-same">1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p>
                        <p class="p-same">2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p>
                        <p class="p-same">3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p>
                        <p class="p-same">4：link支持使用Javascript控制DOM去改变样式；而@import不支持。</p>
                    </section>
                    <!-- Question 6 -->
                    <h4 class="bg-primary">Q6:CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?</h4>
                    <section class="bg-danger">
                        <p class="p-same">1.大类有：元素选择符，关系选择符，属性选择符，伪类选择符，伪对象选择符，细分则有ID选择器，类选择器，子选择器，hover，after等等。</p>
                        <p class="p-same">2.所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。 块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。
                        </p>
                        <p class="p-same">3.important&gt;内联&gt;ID&gt;类&gt;标签&gt;伪对象&gt;继承&gt;通配符</p>
                        <p class="p-same">4.important优先级高于内联</p>
                    </section>
                    <!-- Question 7 -->
                    <h4 class="bg-primary">Q7:前端页面有哪三层构成，分别是什么?作用是什么?</h4>
                    <section class="bg-danger">
                        <p class="p-same">1.结构层 /表示层/行为层</p>
                        <p class="p-same">2.结构层(structural layer) 由 HTML 或 XHTML之类的标记语言负责创建，对网页内容的语义含义做出了描述；表示层(presentation layer) 由 CSS 负责创建，CSS对“如何显示有关内容”的问题做出了回答；行为层(behavior layer) 负责回答“内容应该如何对事件做出反应”这一问题，这是 Javascript 语言和 DOM主宰的领域。</p>
                    </section>
                    <!-- Question 8 -->
                    <h4 class="bg-primary">Q8:CSS的基本语句构成是?</h4>
                    <p class="bg-danger"><code>selector{attribute1:value1;attribute2:value2;attribute3:value3;attribute4:value4;......}</code></p>
                    <!-- Question 9 -->
                    <h4 class="bg-primary">Q9:你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?</h4>
                    <p class="bg-danger">IE(Trident内核)/Firefox(Gecko内核)/Chrome(Blink内核)/Opera(Blink内核)/Safari(Webkit内核)</p>
                    <!-- Question 10 -->
                    <h4 class="bg-primary">Q10:div+css的布局较table布局有什么优点？</h4>
                    <section class="bg-danger">
                        <p class="p-same">1.改版的时候更方便，只要改css文件；</p>
                        <p class="p-same">2.页面加载速度更快、结构化清晰、页面显示简洁；</p>
                        <p class="p-same">3.表现与结构相分离；</p>
                        <p class="p-same">4.易于优化(seo)搜索引擎更友好，排名更容易靠前。</p>
                    </section>
                    <!-- Question 11 -->
                    <h4 class="bg-primary">Q11:写出几种IE6 BUG的解决方法</h4>
                    <section class="bg-danger">
                        <p class="p-same">1.双边距BUG：使用float时出现，添加<code>display:inline-block;</code>属性解决此问题；</p>
                        <p class="p-same">2.3像素问题：使用float时出现，添加<code>display:inline-block;margin:-3px;</code>解决此问题；</p>
                        <p class="p-same">3.超链接hover点击后失效：使用正确的书写顺序 link visited hover active；</p>
                        <p class="p-same">4.z-index问题：给父级添加<code>position:relative;</code>；</p>
                        <p class="p-same">5.png透明：使用js修改；</p>
                        <p class="p-same">6.min-height：!important；</p>
                        <p class="p-same">7.select在ie6下遮盖：使用iframe嵌套；</p>
                    </section>
                    <!-- Question 12 -->
                    <h4 class="bg-primary">Q12:img标签上title与alt属性的区别是什么?</h4>
                    <p class="bg-danger">alt：当图片不显示时用文字表示图片；title：该属性为设置该属性的元素提供建议性的信息。</p>
                    <!-- Question 13 -->
                    <h4 class="bg-primary">Q13:描述css reset的作用和用途，举几个常见的reset库。</h4>
                    <p class="bg-danger">Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一；比较常用的reset库有reset.css、normalize.css、net.css等。</p>
                    <!-- Question 14 -->
                    <h4 class="bg-primary">Q14:浏览器标准模式和怪异模式之间的区别是什么?</h4>
                    <p class="bg-danger">标准模式和怪异模式之间的区别主要是对盒子模型的渲染方式不同。</p>
                    <!-- Question 15 -->
                    <h4 class="bg-primary">Q15:清除浮动的几种方式，各自的优缺点。</h4>
                    <section class="bg-danger">
                        <p class="p-same">1.父级元素设置合适的高度，不需增加额外的标签及样式，缺点是需要事先确定内容高度才能应用此方式；</p>
                        <p class="p-same">2.新增一个嵌套的DIV，使用<code>clear:both;</code>，优点是可以自适应高度，缺点是会增加额外的标签及样式；</p>
                        <p class="p-same">3.父级元素使用<code>overflow:hidden;</code>，简单易用，缺点是需要单独对IE进行兼容设置。</p>
                        <p class="p-same">4.利用伪类清除浮动。</p>
                    </section>
                    <!-- Question 16 -->
                    <h4 class="bg-primary">Q16:简述一下src与href的区别。</h4>
                    <section class="bg-danger">
                        <p class="p-same">src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</p>
                        <p class="p-same">src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。
                            <code>&lt;script src="js.js"&gt;&lt;/script&gt;</code> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。<strong>这也是为什么将js脚本放在底部而不是头部</strong>。
                        </p>
                        <p class="p-same">href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素(锚点)或当前文档(链接)之间的链接，如果我们在文档中添加
                            <code>&lt;link href="common.css" rel="stylesheet" /&gt; </code>那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。<strong>这也是为什么建议使用link方式来加载css，而不是使用@import方式</strong>。
                        </p>
                    </section>
                    <!-- Question 17 -->
                    <h4 class="bg-primary">Q17:网页制作会用到的图片格式有哪些？</h4>
                    <p class="bg-danger">png-8，png-24，jpeg，gif，svg，webp，apng</p>
                    <!-- Question 18 -->
                    <h4 class="bg-primary">Q18:如何理解HTML结构的语义化？</h4>
                    <section class="bg-danger">
                        <p class="p-same"><strong>HTML语义化的核心思想是增强HTML页面的可读性。</strong></p>
                        <p class="p-same">去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如<code>&lt; h1&gt; </code>是粗体，字体大小2em，加粗；<code>&lt; strong&gt; </code>是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</p>
                        <p class="p-same">PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页(通常是因为这些设备对CSS的支持较弱)使用语义标记可以确保这些设备以一种有意义的方式来渲染网页：理想情况下，观看设备的任务是符合设备本身的条件来渲染网页。语义标记为设备提供了所需的相关信息，就省去了你自己去考虑所有可能的显示情况(包括现有的或者将来新的设备)。例如，一部手机可以选择使一段标记了标题的文字以粗体显示。而掌上电脑可能会以比较大的字体来显示。无论哪种方式一旦你对文本标记为标题，您就可以确信读取设备将根据其自身的条件来合适地显示页面。
                        </p>
                        <p class="p-same">搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重 ：过去你可能还没有考虑搜索引擎的爬虫也是网站的“访客”,但现在它们他们实际上是极其宝贵的用户。没有他们的话，搜索引擎将无法索引你的网站，然后一般用户将很难过来访问。
                        </p>
                    </section>
                    <!-- Question 19 -->
                    <h4 class="bg-primary">Q19:在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</h4>
                    <p class="bg-danger">dns缓存，cdn缓存，浏览器缓存，服务器缓存。</p>
                    <!-- Question 20 -->
                    <h4 class="bg-primary">Q20:解释css sprites，如何使用。</h4>
                    <p class="bg-danger">CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的<code>background-image</code>，<code>background- repeat</code>，<code>background-position</code>的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。</p>
                    <!-- Question 21 -->
                    <h4 class="bg-primary">Q21:px，em，rem的区别</h4>
                    <section class="bg-danger">
                        <p class="p-same">px是你屏幕设备物理上能显示出的最小的一个点，这个点不是固定宽度的，不同设备上点的长宽、比例有可能会不同。</p>
                        <p class="p-same">em是相对于父级元素的尺寸大小来确定的值</p>
                        <p class="p-same">rem相对于html/body标签的全局设定来确定的值</p>
                    </section>
                    <!-- Question 22 -->
                    <h4 class="bg-primary">Q22:<code>display:none;</code>与<code>visibility:hidden;</code>的区别是什么？</h4>
                    <section class="bg-danger">
                        <p class="p-same"><code>display:none;</code>：隐藏对应的元素但不挤占该元素原来的空间。</p>
                        <p class="p-same"><code>visibility:hidden;</code>：隐藏对应的元素并且挤占该元素原来的空间。</p>
                    </section>
                    <!-- Question 23 -->
                    <h4 class="bg-primary">Q23:CSS content属性有什么作用？有什么应用？</h4>
                    <p class="bg-danger">css的content属性专门应用在 before/after 伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。
                    </p>
                    <!-- Question 24 -->
                    <h4 class="bg-primary">Q24:如何对网站的文件和资源进行优化?</h4>
                    <section class="bg-danger">
                        <p class="p-same">1.文件合并(目的是减少http请求)：Web性能优化最佳实践中最重要的一条是减少HTTP 请求，它也是YSlow中比重最大的一条规 则。减少HTTP请求的方案主要有合并JavaScript和CSS文件、CSS Sprites、图像映射 (Image Map)和使用Data URI来编码图片。CSS Sprites和图像映射现在已经随处可见了，但由于IE6和IE7不支持Data URI以及性能问题，这项技术尚未大量使用。目前大部分网页中的JavaScript和CSS文件数量和开发时一致，少量的网页会根据实际情况采取本地合 并，这些合并中相当多的是有选择地手动完成，每次新的合并都需要重新在本地完成并上传到服务器，比较的随意和繁琐，同样文件的压缩也有类似的情况。而利用 服务端的合并和压缩，我们就可以按照开发的逻辑尽可能让文件的颗粒度变小，利用网页中URL的规则来自动实现文件的合并和压缩，这会相当的灵活和高效。</p>
                        <p class="p-same">2.文件压缩：目的是直接减少文件下载的体积；常用的工具是YUI Compressor。</p>
                        <p class="p-same">3.使用 CDN (内容分发网络)来托管资源：其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>
                        <p class="p-same">4.缓存的使用：利用多个域名来存储网站资源。</p>
                    </section>
                    <!-- Question 25 -->
                    <h4 class="bg-primary">Q25:为什么利用多个域名来存储网站资源会更有效？</h4>
                    <section class="bg-danger">
                        <p class="p-same">1.CDN缓存更方便</p>
                        <p class="p-same">2.突破浏览器并发限制</p>
                        <p class="p-same">3.节约cookie带宽</p>
                        <p class="p-same">4.节约主域名的连接数，优化页面响应速度 </p>
                        <p class="p-same">5.防止不必要的安全问题 </p>
                    </section>
                    <h4 class="bg-primary">Q26:
<pre>
function Foo(){
    getName = function (){alert(1)};
    return this;
}
Foo.getName = function (){alert(2)};
Foo.prototype.getName = function (){alert(3)};
var getName = function (){alert(4)};
function getName(){alert(5)};

//请写出如下输出结果
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName()
</pre>
                    </h4>
                    <section class="bg-danger">
                        <p class="p-same">执行结果如下：</p>
                        <pre>
            Foo.getName();  //2
            getName();  //4
            Foo().getName();  //1
            getName();  //1
            new Foo.getName();  //2
            new Foo().getName();  //3
            new new Foo().getName()  //3</pre>
                        <p class="p-same">本题首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数，之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName的函数。此题涉及到的知识点：<code>变量定义提升</code>、<code>this指针指向</code>、<code>运算符优先级</code>、<code>原型</code>、<code>继承</code>、<code>全局变量污染</code>、<code>对象属性</code>及<code>原型属性优先级</code>等，以下进行分别说明。</p>
                        <br />
                        <p class="p-same">第一问</p>
                        <br />
                        <p class="p-same">Foo.getName访问Foo函数上存储的静态属性，所以结果为2</p>
                        <br />
                        <p class="p-same">第二问</p>
                        <br />
                        <p class="p-same">直接调用getName函数，既然是直接调用那么就是直接访问当前上文作用域内叫getName的函数，所以1/2/3都没有什么关系，答案将在4/5之间选择，此处有两个知识点<code>变量声明提升</code>和<code>函数表达式</code>。</p>
                        <p class="p-same"><code>变量声明提升</code>即所有声明变量或声明函数都会被提升到当前函数的顶部。例如如下代码：</p>
                        <pre>
            console.log('x' in window);  //true
            var x;
            x = 0;</pre>
                        <p class="p-same">执行时JS引擎会将声明语句提升至代码最上方，变为：</p>
                        <pre>
            var x;
            console.log('x' in window);  //true
            x = 0;</pre>
                        <p class="p-same"><code>函数表达式</code>，var getName与function getName都是声明语句，区别在于var getName是函数表达式，而function getName是函数声明。函数表达式最大的问题在于，JS引擎会将代码拆分为两行代码分别执行。例如：</p>
                        <pre>
            console.log(x);  //输出：function x(){}
            var x=1;
            function x(){}</pre>
                        <p class="p-same">实际执行的代码为，先将var x = 1 拆分为 var x;和 x = 1;两行，再将var x;和function x(){}两行提升至最上方：</p>
                        <pre>
            var x;
            function x(){};
            console.log(x); 
            x=1</pre>
                        <p class="p-same">所以最终函数声明的x覆盖了变量声明的x，log输出为x函数。</p>
                        <p class="p-same">同理，原题中代码最终执行的是：</p>
                        <pre>
            function Foo(){
                getName = function (){alert(1)};
                return this;
            }
            var getName;  //只提升变量声明
            function getName(){alert(5)}  //提升函数声明，覆盖var的声明

            Foo.getName = function (){alert(2)};
            Foo.prototype.getName = function (){alert(3)};
            getName = function (){alert(4)};  //最终赋值再次覆盖function getName声明

            getName()  //最终输出4</pre>
                        <br />
                        <p class="p-same">第三问</p>
                        <br />
                        <p class="p-same">Foo().getName()先执行了Foo函数，然后调用Foo的返回值对象的getName属性函数。</p>
                        <p class="p-same">Foo函数的第一句 getName = function (){alert(1)}是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有找到。再向上寻找，即外层作用域内寻找是否含有getName变量，找到后将返回值赋予getName变量，<code>此处实际上是将外层作用域中的getName变量值修改了</code>。</p>
                        <p class="p-same">Foo函数的返回值是this，而JS的this指向是由所在函数的调用方式决定的，此处直接调用，this指向window对象，其实质就是执行这条语句后将window对象中的getName变量修改为alert(1).</p>
                        <br />
                        <p class="p-same">第四问</p>
                        <br />
                        <p class="p-same">直接调用getName函数，相当于window.getName()，因为这个变量已经被Foo函数执行时修改了，所以结果将会是alert(1)。</p>
                        <br />
                        <p class="p-same">第五问</p>
                        <br />
                        <p class="p-same">new Foo.getName()，此处考察的是JS的<code>运算符优先级问题</code>，可以参考链接<a href="https://technet.microsoft.com/zh-cn/library/z3ks45k7">运算符优先级 (JavaScript)</a>。</p>
                        <p class="p-same">通过查表可以得知 '.' 的优先级高于new操作，于是可以等价于：</p>
                        <pre>
            new (Foo.getName)();</pre>
                        <p class="p-same">所以实际上将getName函数作为了构造函数来执行，结果为2。</p>
                        <br />
                        <p class="p-same">第六问</p>
                        <br />
                        <p class="p-same">第六问 new Foo().getName()，首先看运算符优先级括号高于new，实际执行为：</p>
                        <pre>
            (new Foo()).getName();</pre>
                        <p class="p-same">于是先执行Foo函数，而Foo此时作为构造函数却有返回值，所以这里需要说明下JS中的<code>构造函数返回值</code>问题。</p>
                        <p class="p-same"><code>构造函数返回值</code>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。但是在JS中构造函数可以有返回值也可以没有。</p>
                        <p class="p-same">1.没有返回值则按照其他语言一样返回实例化对象。</p>
                        <p class="p-same">2.若有返回值则检查其返回值是否为引用类型，如果是非引用类型，如基本类型(string/number/boolean/null/undefined)则与无返回值相同，实际返回其实例化对象。</p>
                        <p class="p-same">3.若返回值是引用类型，则实际返回值为这个引用类型。</p>
                        <p class="p-same">原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。</p>
                        <p class="p-same">之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象(prototype)中寻找getName，原型下存在getName，遂输出为3。</p>
                        <br />
                        <p class="p-same">第七问</p>
                        <br />
                        <p class="p-same">new new Foo().getName()，同上思路，属于运算符优先级问题，实际执行为：</p>
                        <pre>
            new ((new Foo()).getName())();</pre>
                        <p class="p-same">先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再new一次，运行结果为3。</p>
                    </section>
                    <h4 class="bg-primary">Q27:
<pre>
function fun(n,o){  //
    console.log(o);
    return {
        fun:function (m){ //[2]
            return fun(m,n);  //[1]
        }
    }
}

//求程序输出
var a = fun(0);
a.fun(1);
a.fun(2);
a.fun(3); 
var b = fun(0).fun(1).fun(2).fun(3); 
var c = fun(0).fun(1);
c.fun(2);
c.fun(3)</pre>
                    </h4>
                    <section class="bg-danger">
                        <p class="p-same">执行结果如下：</p>
                        <pre>
            var a = fun(0); //undefined
            a.fun(1);  //0
            a.fun(2);  //0
            a.fun(3);  //0
            var b = fun(0).fun(1).fun(2).fun(3);  //undefined,0,1,2
            var c = fun(0).fun(1);  //undefined,0
            c.fun(2);  //1
            c.fun(3)  //1</pre>
                        <br />
                        <p class="p-same">转换为等价代码</p>
                        <br />
                        <p class="p-same">外层fun函数返回的对象包含一个fun属性，fun属性对应一个新建的匿名函数对象，这个函数对象将形成一个闭包作用域，使其能够访问外层函数的变量n及外层的fun函数，为了不将fun函数与fun属性弄混，改写成如下的等价模式：</p>
                        <pre>
            function _fun_(n,o){
                console.log(o);
                return {
                    fun:function (m){
                        return _fun_(m,n);
                    }
                }
            }

            var a = _fun_(0); //undefined
            a.fun(1);  //0
            a.fun(2);  //0
            a.fun(3);  //0
            var b = _fun_(0).fun(1).fun(2).fun(3);  //undefined,0,1,2
            var c = _fun_(0).fun(1);  //undefined,0
            c.fun(2);  //1
            c.fun(3)  //1</pre>
                        <p class="p-same">在函数声明阶段，[2]处的匿名函数进行定义声明时，需要在[1]处返回一个名为fun的函数对象，首先会在当前函数体内寻找，发现没有，则会到上一层的对象中去寻找，依然没有找到，会继续向上，在本题中会一直找到全局环境(window对象)，然后匹配到全局环境中的fun函数，于是fun函数返回的对象中的fun属性下的匿名函数会将全局的fun函数加入到自己的闭包中去。</p>
                        <br />
                        <p class="p-same">创建闭包作用域</p>
                        <br />
                        <p class="p-same">JS在语法分析结束后，确定了一个闭包，就是返回的对象fun属性对应的匿名函数的闭包，访问全局环境下的 _fun_及其外层函数的函数内部变量n，在每次 _fun_执行的时候，都会将闭包中变量的作用域信息传递到函数执行环境中，供函数执行时获取变量值。</p>
                        <br />
                        <p class="p-same">执行输出</p>
                        <br />
                        <pre>
            var a = _fun_(0); //undefined
            a.fun(1);  //0
            a.fun(2);  //0
            a.fun(3);  //0</pre>
                        <p class="p-same">_fun_函数执行，因为第二个参数未定义，输出为undefined。然后返回一个对象，带有fun属性，指向一个函数对象，能够访问到_fun_和变量n，<code>a.fun(1)</code>执行返回对象的fun属性，传入m的值1，调用_fun_(1,0)，所以输出为0，以此类推。</p>
                        <pre>
            var b = _fun_(0).fun(1).fun(2).fun(3);</pre>
                        <p class="p-same">等级代码</p>
                        <pre>
            var b = _fun_(0);
            var b1 = b.fun(1);
            var b2 = b1.fun(2);  //[3]
            var b3 = b2.fun(3);  //[4]</pre>
                        <p class="p-same">前两句和上面的输出相同为undefined/0，当[3]被调用时，b1对象中有一个闭包，引用了_fun_函数及外层函数变量n = 1，所以匿名函数执行后的返回值会调用_fun_(2,1)，输出结果为1，并返回一个新对象，当[4]执行时，原理同上，将会执行_fun_(3,2)，输出结果为2。</p>
                        <p class="p-same">推理过程如上，得到var c的输出为undefined/0/1/1。</p>
                        <br />
                        <p class="p-same">补充说明：闭包的优缺点</p>
                        <br />
                        <p class="p-same">主要优点：</p>
                        <p class="p-same">1.逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑；</p>
                        <p class="p-same">2.方便调用上下文的局部变量；</p>
                        <p class="p-same">3.加强封装性，保护局部变量不受污染。</p>
                        <p class="p-same">主要缺点：</p>
                        <p class="p-same">闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。</p>
                    </section>
                    <h4 class="bg-primary">Q28:什么是AJAX，为什么要使用AJAX，谈一谈你对AJAX的认识。</h4>
                    <section class="bg-danger">
                        <p class="p-same">AJAX是"Asysnchronous JavaScript and XML"的缩写，它表示异步的Javscript和XML，是一种创建交互式网页应用的网页开发技术，通过异步模式，实现页面的局部刷新，优化了浏览器与服务器之间的传输，减少不必要的数据往返，减少带宽占用，提升用户体验。</p>
                        <p class="p-same">AJAX技术体系的主体包括HTML/CSS/DOM/XML/XMLHttpRequest/Javascript，其核心是JavaScript对象XmlHttpRequest，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。</p>
                        <p class="p-same">XMLHttpRequest对象的常用方法和属性：</p>
                        <p class="p-same">open('method','url')建立对服务器的调用，第一个参数是HTTP请求方式可以为GET，POST或任何服务器所支持调用的式，第二个参数是请求页面的url；</p>
                        <p class="p-same">send()方法，发送具体请求；</p>
                        <p class="p-same">abort()方法，停止当前请求；</p>
                        <p class="p-same">responseText属性，服务器的响应，表示为一个string；</p>
                        <p class="p-same">reponseXML属性，服务器的响应，表示为XML；</p>
                        <p class="p-same">status属性，服务器的HTTP状态码，200对应ok/400对应not found。</p>
                        <p class="p-same">AJAX的缺点：1、AJAX不支持浏览器back按钮； 2、AJAX暴露了与服务器交互的细节，存在安全隐患；3、对搜索引擎的支持比较弱；4、破坏了程序的异常机制；5、不容易调试。
                        </p>
                    </section>
                    <h4 class="bg-primary">Q29:JS中数组去重和降维的思路与方法。</h4>
                    <section class="bg-danger">
                        <br />
                        <p class="p-same">数组去重</p>
                        <br />
                        <p class="p-same">方法一：</p>
                        <pre>
            /*
            *1.构建一个新的数组存放结果
            *2.使用for循环每次从原数组中取出一个元素，用这个元素与结果数组进行对比
            *3.若新数组中没有该元素，则将原数组中取出的元素存到新数组中
            */

            Array.prototype.Unique = function(){
                var res = [this[0]];
                for(var i = 1; i < this.length; i++){
                    var repeat = false;
                    for(var j = 0; j < res.length; j++){
                        if(this[i] == res[j]){
                            repeat = true;
                            break;
                        }
                    }
                    if(!repeat){
                        res.push(this[i]);
                    }  
                }
                return res;
            }

            //测试
            var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0];
            console.log(arr.Unique())</pre>
                        <p class="p-same">方法二：</p>
                        <pre>
            /*
            *1.将原数组进行排序
            *2.检查员数组中的第i个元素与结果数组中的最后一个元素是否相同，因为已经完成排序，所以相同元素会处于相同位置
            *3.如果结果不同，则将原数组中的该元素存入结果数组中
            */

            Array.prototype.Unique = function(){
                this.sort();
                var res = [this[0]];
                for(var i = 1; i < this.length; i++){
                    if(this[i] !== res[res.length - 1]){
                        res.push(this[i]);
                    }  
                }
                return res;
            }

            //测试
            var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0];
            console.log(arr.Unique())

            //这种方法会改变原数组的排序方式，如果要求不能改变数组的顺序，则这种方式不可取</pre>
                        <p class="p-same">方法三</p>
                        <pre>
            /*
            *1.创建一个新的数组存放结果
            *2.创建一个新对象
            *3.对数组元素进行for循环时，每次取出一个元素与对象对比，如果这个元素不重复，则把它放到结果数组中，同时把这个元素的内容作为对象的属性，并赋值1，存入到新建对象中
            *4.遍历原数组中的所有元素，同时在对象中访问这个属性，如果对象中这个属性已存在，则说明重复
            */

            Array.prototype.Unique = function(){
                var res = [];
                var obj = {};
                for(var i = 0; i < this.length; i++){
                    if(!obj[this[i]]){
                        res.push(this[i]);
                        obj[this[i]] = 1;
                    }  
                }
                return res;
            }

            //测试
            var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0];
            console.log(arr.Unique())</pre>
                        <br />
                        <p class="p-same">数组降维</p>
                        <br />
                        <p class="p-same">方法一：</p>
                        <pre>
            /*
            *利用双重循环遍历二维数组中的每个元素并放到新数组中
            */

            function reduceDimension(arr){
                var res = [];
                for(var i = 0; i < arr.length; i ++){
                    for(var j = 0; j < arr[i].length; j ++){
                        res.push(arr[i][j]);
                    }
                }
                
                return res;
            }

            //测试
            var arr = [[1,6,9],[18,23],[2,3,1]];
            console.log(reduceDimension(arr))</pre>
                        <p class="p-same">方法二：</p>
                        <pre>
            /*
            *利用concat转换，如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是数组，则该数组的各个元素将被直接插入到新数组中
            */

            function reduceDimension(arr){
                var res = [];
                for(var i = 0; i < arr.length; i ++){
                    res = res.concat(arr[i])
                }
                
                return res;
            }

            //测试
            var arr = [[1,6,9],[18,23],[2,3,1]];
            console.log(reduceDimension(arr))</pre>
                        <p class="p-same">方法三：</p>
                        <pre>
            /*
            *利用concat+apply转换，apply方法会调用一个方法，apply方法的第一个参数会作为被调用函数的this值，第二个参数(数组)会作为被调用对象的arguments值。
            */

            function reduceDimension(arr){
                return Array.prototype.concat.apply([],arr);
            }

            //测试
            var arr = [[1,6,9],[18,23],[2,3,1]];
            console.log(reduceDimension(arr))</pre>
                    </section>
                </article>
                <!-- page foot -->
                <footer class="text-center">
                    <h3>The End</h3>
                </footer>
            </div>
        </div>
    </div>
</body>

</html>
